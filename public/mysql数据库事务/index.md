# MySQL数据库事务


### 什么是事务

事务是数据库管理系统执行过程中的一个逻辑单元，由一个有限的数据库操作序列构成。这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始和事务结束之间的全部数据库操作组成。

### 事务的特性

事务具有四个特性ACID，分别是atomicity原子性、consistency一致性、isolation隔离性、durability一致性

> 原子性

一个事务必须被事务一个不可分割的最小单元，整个事务的所有操作要么全部成功，要么全部失败。对于一个事务来说不能只执行其中一部分操作。

> 一致性

一致性是指事务必须使数据库从一种一致状态转换到另一种一致状态。在事务开始之前和事务结束之后，数据库的完整性没有被破坏。

完整性主要包括：实体完整性、域完整性、参照完整性

> 隔离性

一个事务执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对于其他事务来说是隔离的，并发执行的各个事务之间不能互相干扰。

> 持久性

一旦事务提交，则其所做的修改就会被永久保存到数据库中，即使系统崩溃，已经提交的数据也不会丢失。

### 并发事务的问题

我们知道MySQL是一个客户端／服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（Session）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。

在上面我们说过事务有一个称之为隔离性的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据，这样的话并发事务的执行就变成了串行化执行。

但是对串行化执行性能影响太大，我们既想保持事务的一定的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，当我们舍弃隔离性的时候，可能会带来什么样的数据问题呢？

#### 脏读

当一个事务读取到了另一个事务修改但未提交的数据，被称为脏读。

![05e67865973a410e93190c52a74be697](https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406041613975.png)

1. 事务A在执行过程中，对数据资源进行了修改
2. 事务B在A执行修改后读取了数据
3. 由于某些原因A并没有提交事务，而是发生了回滚，则之前的修改应是无效的，但是B已经读取了数据，就是脏数据。

#### 不可重复读

当事务内相同的记录被检索了两次或多次，但是却得到不同的结果时，被称为不可重复读。

![3895ad68683747e88b114bba40f48ad9](https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406041613532.png)

在事务B两次读取数据中间，事务A对数据进行了修改操作，导致事务B两次的查询结果不一致。

#### 幻读

在事务执行过程中，如果有两次或多次的范围查询，在这些范围查询之间，另一个事务对这些数据进行添加或删除的操作，导致范围查询的数据条目增加或减少，第一个事务两次或多次范围查询得到的数据条目不一致。

![3a92feb9aa014a7eaaf784d1c7057822](https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406041612813.png)

事务B前后两次读取同⼀个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后⼀次读取到前⼀次查询没有看到的⾏。

**注意**：幻读和不可重复读有些类似，但是幻读重点强调读取到了之前不存在的数据或之前存在但是后面又没了的数据。

#### 隔离级别

在SQL标准中有四个隔离级别，分别是读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）、串行化（Serializable）

> 读未提交

一个事务可以读取另一个事务未提交的数据。这是最低级别的隔离级别，可能会导致脏读、不可重复读和幻读

> 读已提交

一个事务只能读取另一个已提交事务的数据。可以防止脏读，但会出现不可重复读和幻读。

原理：在读已提交的隔离级别下，事务1先读取数据，但未提交，此事事务2仍然可以继续修改数据。这是因为读已提交的隔离级别关注的是读取的数据是否已经被其他事务提交，而不是本身是否正在读取数据。

> 可重复读

在一个事务中多次读取同一数据会返回相同结果，即使其他事务已经修改了这些数据并提交。可以防止脏读和不可重复读，但是可能会出现幻读。这一级别是MySQL InnoBD引擎的默认级别。

原理：通过多版本控制并发（MVCC）和行级锁来实现。下面详细介绍什么是MVCC

> 串行化

最高的隔离级别，要求事务串行执行，即事务之间没有并发。

原理：对于同一行记录，读写分别会加读写锁，出现读写锁冲突时，后访问的事务必须等待前一个事务执行完成才能够继续。

**注意**：对于四个隔离级别所能避免的事务并发问题，不要死记硬背，很多人都是看一张表格，然后把表格内容背下来，不去理解原理是记不长久的。

### MVCC

MVCC全称Multi Version Concurrency Control，多版本并发控制，主要是为了提升数据库并发性能。在MVCC中有两个非常重要的概念：版本链和ReadView（视图），下面先来介绍这两个概念。

#### 版本链

首先要知道的是，对于使用InnoDB作为存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：trx_id和roll_pointer（注意：不是row_id，如果我们创建表的适时候表中有主键，或非NULL的UNIQUE键时都不会包含row_id列）。

> trx_id

这个隐藏列用于存储最近一次修改该记录的事务的事务ID。当一个事务对某条聚簇索引记录进行插入或更新时，该事务的ID会被赋值给trx_id。但查询操作本身不会修改记录，因此它不会改变trx_id的值。

> roll_pointer

这个隐藏列是一个指向undo日志的指针。当一个事务修改了一条记录时，旧版本的记录会被复制到undo日志中，并且新版本日志中的roll_pointer会指向这个undo日志条目。

**注意**：为了实现事务的原子性，InnoDB存储引擎在进行实际增删改一条记录时，都需要先把对应的undo日志记下来。一般每对一条记录做一次改动，就对应着一条undo日志，但是一个事务执行过程中，可能新增、删除、修改若干条记录，也就会产生若干条undo日志，这些日志会从0开始编号。

为了理解版本链，我们创建一个演示表teacher

```sql
CREATE TABLE teacher (
number INT,
name VARCHAR(100),
domain varchar(100),
PRIMARY KEY (number)
) Engine=InnoDB CHARSET=utf8;
```

然后向表中插入一条数据

```sql
INSERT INTO teacher VALUES(1, '李瑾', 'JVM系列');
```

假设插入该记录的事务id为60，那么此刻该条记录的示意图如下所示：

![c7b3d5e8c3bd4d91942b0891b0db0956](https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406052007508.png)

假设之后两个事务id分别为80、120的事务对这条记录进行UPDATE操作，操作流程如下：

<img src="https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406052008671.png" alt="85471f9eaddf4d42a51259b6878056ed" style="zoom: 67%;" />

每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：

![c7dc3b48519b4961b04e03594ee80538](https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406052009874.png)

对记录的每次修改都会将旧值放到undo日志当中，就算是该记录的一个旧版本，随着更新次数的增加，所有的版本记录都会被roll_pointer属性连接成一个链表，我们把这个链表称为版本链，版本链的头节点就是这条记录的最新值。另外，每个版本中还包含生成该版本时对应的事务id。于是可以利用这个版本链来控制并发事务访问相同记录的行为，这种机制就叫做MVCC

#### ReadView

ReadView是一个事务进行快照读时产生的数据读试图。当事务执行快照读时，会产生一个数据系统当前的快照，这个快照就是ReadView。ReadView提供了选择哪个版本数据的依据，它决定了事务在某一时刻能看到那些版本的数据。

> 组成部分

m_ids：事务ID集合，表示在生成ReadView时，当前系统中活跃的读写事务的事务id列表

min_trx_id：表示在生成ReadView时，当前系统中活跃的读写事务的id最小值，也就是m_ids中的最小值

max_trx_id：表示在生成ReadView时，当前系统中应该分配的下一个事务的id。并不是m_ids中的最大值。

creator_trx_id：表示生成该ReadView的事务的事务id。

例如，现在有id为1，2，3，4四个事务，其中id为3的事务提交了，其余没有提交，且id为4的事务中进行了快照读操作，那么m_ids=[1，2，3]，min_trx_id=1，creator_id=4，但是max_trx_id=5，因为事务id是自增分配的。

#### 原理

在了解了版本链和ReadView的概念后，我们来看看ReadCommitted是如何解决脏读以及RepeatedRead是如何解决可重复读的问题的。

> ReadCommitted

1. ReadCommitted隔离级别中的事务在每次开始执行查询时，都会生成一个独立的ReadView，其中ReadView的creator_trx_id就是当前事务的id。

2. 有了ReadView后，在执行查询时，会先拿自己产生的ReadView的creator_id去和被访问记录的版本的trx_id进行比较。

   - 只能比较不在m_ids列表中的事务id，m_ids列表中的事务处于活跃状态，它的数据对其他事务不可见。（解决脏读问题的关键）

   - 如果creator_trx_id等于trx_id就说明当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
   - 如果被访问版本的trx_id小于creator_trx_id，表明生成该版本的事务是在生成当前ReadView前就以及提交了，所以该版本可以被访问
   - 如果被访问版本的trx_id大于creator_trx_id，就要看trx_id是否小于max_trx_id如果小于，则可见，如果大于则不可见。

下面看个例子：

<img src="https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406052008671.png" alt="85471f9eaddf4d42a51259b6878056ed" style="zoom: 67%;" />

还是这个图，两个事务，都对同一条记录做修改，但是均未提交，版本链也如之前介绍的一样。若此时执行一条查询语句`SELECT * FROM teacher WHERE number = 1;`（假设事务id是130）

查询过程：

1. 生成一个ReadView，ReadView的m_ids列表就是[80, 120]（不包含自己的事务id） min_trx_id=80，max_trx_id=131，creator_trx_id=130。
2. 访问版本链的头节点，发现trx_id是120，在活跃事务集合中，不符合要求。继续往下找，直到找到trx_id=60的undo记录，小于当前的creator_trx_id，符合要求。
3. 返回结果：得到的列name的值为'李瑾'的记录。

思考一下：为什么只能解决脏读，无法解决不可重复读问题呢？下面简单文字描述一下

因为ReadCommited隔离级别是每次查询时都会生成一个ReadVew，那么如果在同一个事务（T1）内部的两个查询（S1和S2）之间，有另外一个事务（T2）对记录进行修改并提交。

1. T2在第一个S1开始前执行，在S2开始前提交
   - S1开始前产生的ReadView中的m_ids中会包含T2，因为此时T2已经开始执行，处于活跃状态。所以S1看不到T2的结果
   - S2开始前T2结束，则S2产生的ReadView中不包含T2，且此时的ReadView中的max_trx_id一定大于T2，故S2可以看到T2的结果。
2. T2在S1结束后，S2开始前执行并提交。这个过程比较简单不做赘述

> Repeatable Read

这个的原理和Read Committed基本一致，唯一存在区别的是Repeatable Read并不是在每次查询都会生成一个新的ReadView，而是一个事务中的所有查询都共用一个ReadView，这样自然可以解决可重复读问题。



> Repeatable Read幻读现象

除了MVCC以外，还有行级锁和间隙锁，这三者共同帮助Repeatable  Read预防大部分的幻读问题

在InnoDB中为了防止幻读，当使用范围条件查询时，除了对查询到的行加行锁（Record Locks）外，还会对查询范围内的间隙（Gap）加间隙锁。间隙锁阻止其他事务在这个间隙内插入新的记录，从而确保了在这个事务的后续查询中，不会出现“幻影”行（即之前不存在的行）。

间隙锁和行锁的结合被称为Next-Key Locks。这种锁类型不仅锁定了记录本身，还锁定了记录之前的间隙，从而防止其他事务在这个范围内插入新的记录。

为什么说预防大部分的幻读问题？下面来看看可能会出现的幻读问题

1. 原始数据

![image-20240605231344990](https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406052313037.png)

2. 首先在事务T1中执行`select * from teacher where number = 30;`很明显，这个时候是找不到number = 30的记录的。

![image-20240605231516371](https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406052315422.png)

3. 在事务T2中，执行`insert into teacher values(30,'豹','数据湖');`并提交

![image-20240605231636856](https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406052316902.png)

4. 在事务T1，依次执行

```sql
select * from teacher where number = 30;
update teacher set domain='RocketMQ' where number=30;
select * from teacher where number = 30;
```

![image-20240605231751243](https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406052317292.png)

事务1明显出现了幻读的情况，这是为什么？

在REPEATABLE READ隔离级别下，T1第一次执行普通的SELECT 语句时生成了一个ReadView（但是版本链没有），之后T2向teacher 表中新插入一条记录并提交，然后T1也进行了一个update语句。
ReadView并不能阻止T1执行UPDATE 或者DELETE 语句来改动这个新插入的记录，但是这样一来，这条新记录的trx_id隐藏列的值就变成了T1的事务id。

![92d29ec669db40b1a07fb0b3cc8cb730](https://blogbear.oss-cn-beijing.aliyuncs.com/blogpic/202406052320311.png)

之后T1再使用普通的SELECT 语句去查询这条记录时就可以看到这条记录了，也就可以把这条记录返回给客户端。因为这个特殊现象的存在，我们也可以认为MVCC 并不能完全禁止幻读（**就是第一次读如果是空的情况，且在自己事务中进行了该条数据的修改**）。
